ft_isalpha:    [FAILED] 
[fail]: your isalpha just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isalpha(i) != !!((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISalpha))
			exit(TEST_FAILED);
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:


ft_isdigit:    [FAILED] 
[fail]: your isdigit just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isdigit(i) != !!((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISdigit))
			exit(TEST_FAILED);
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:


ft_isalnum:    [OK] 
ft_isascii:    [FAILED] 
[fail]: your isascii just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isascii(i) != !!(((i) & ~0x7f) == 0))
		{
			exit(TEST_FAILED);
		}
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:
     isascii: |0|
  ft_isascii: |1|
param: (256)

ft_isprint:    [FAILED] 
[fail]: your isprint just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isprint(i) != !!((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISprint))
		{
			exit(TEST_FAILED);
		}
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:
     isprint: |0|
  ft_isprint: |1|
param: (288)

ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[crash]: your memcpy does not behave well with NULL as both params with size
Test code:
	ft_memcpy(((void*)0), ((void*)0), 3);


ft_memmove:    [OK] [OK] [OK] [OK] [CRASH] [CRASH] [OK] [CRASH] [OK] [OK] [OK] [OK] [OK] [OK] 
[crash]: your memmove does not support the overlap (test 1)
Test code:
	char dst1[0xF0];
	char dst2[0xF0];
	char *data = "thiß ß\xde\xad\xbe\xeftriñg will be øvérlapéd !\r\n";
	int size = 0xF0 - 0xF;

	memset(dst1, 'A', sizeof(dst1));
	memset(dst2, 'A', sizeof(dst2));
	memcpy(dst1, data, strlen(data));
	memcpy(dst2, data, strlen(data));
	memmove(dst1 + 3, dst1, size);
	ft_memmove(dst2 + 3, dst2, size);
	if (!memcmp(dst1, dst2, size))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your memmove does not support the overlap (test 2)
Test code:
	char dst1[0xF0];
	char dst2[0xF0];
	char *data = "thiß ß\xde\xad\xbe\xeftriñg will be øvérlapéd !\r\n";
	int size = 0xF0 - 0xF;

	memset(dst1, 'A', sizeof(dst1));
	memset(dst2, 'A', sizeof(dst2));
	memcpy(dst1, data, strlen(data));
	memcpy(dst2, data, strlen(data));
	memmove(dst1, dst1 + 3, size);
	ft_memmove(dst2, dst2 + 3, size);
	if (!memcmp(dst1, dst2, size))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your memmove does not work with a 128Mo data input !
Test code:
	int size = 128 * 1024 * 1024;
	char *dst = (char *)malloc(sizeof(char) * size);
	char *data = (char *)malloc(sizeof(char) * size);

	memset(data, 'A', size);
	if (!dst)
		exit(TEST_INVISIBLE);
	ft_memmove(dst, data, size);
	exit(TEST_SUCCESS);


ft_strlcpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcat:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] 
[no crash]: your strchr does not segfault with NULL parameter
Test code:
	ft_strchr(((void*)0), '\0');


ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] [NO CRASH] 
[no crash]: your strncmp does not segfault when null parameter is sent
Test code:
	ft_strncmp(((void*)0), "nope", 3);


[no crash]: your strncmp does not segfault when null parameter is sent
Test code:
	ft_strncmp("nope", ((void*)0), 3);

	ft_strncmp(((void*)0), ((void*)0), 3);


ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] 
[no crash]: your memchr does not segfault when null param is sent
Test code:
	ft_memchr(((void*)0), '\0', 0x20);


ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strnstr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] 
[no crash]: your atoi does not work with the plus sign and spaces
Test code:
	ft_atoi(((void*)0));


ft_calloc:     [OK] [OK] [OK] [OK] [OK] 
ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strjoin:    [OK] [OK] [OK] [OK] [OK] 
ft_strtrim:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_split:      [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] 
[crash]: you did not protect your split
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	if (!result)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_itoa:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strmapi:    [OK] [OK] [OK] [OK] [OK] 
ft_striteri:   [OK] [OK] 
ft_putchar_fd: [OK] [OK] 
ft_putstr_fd:  [OK] [OK] 
ft_putendl_fd: [OK] [OK] 
ft_putnbr_fd:  [OK] [OK] [OK] [OK] [OK] 
ft_lstnew:     [OK] [OK] [OK] [OK] 
ft_lstadd_front: [OK] [OK] [OK] 
ft_lstsize:    [OK] [OK] 
ft_lstlast:    [OK] [OK] 
ft_lstadd_back:[OK] [OK] [OK] 
ft_lstdelone:  [OK] 
ft_lstclear:   [OK] [OK] [OK] 
ft_lstiter:    [OK] 
ft_lstmap:     [OK] 
